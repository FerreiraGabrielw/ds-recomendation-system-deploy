---
title: "Hybrid Recommender System for E-commerce (End-to-End)"
author: "Gabriel Ferreira"
date: "2025-12-19"
format:
  html:
    page-layout: full
    code-fold: true
    code-summary: "Show Code"
    toc: true
    toc-depth: 1
    toc-title: "Project Index"
    anchor-sections: false
engine: jupytern
jupyter: python3
---

## # Introduction

Este projeto desenvolve um **sistema de recomendaÃ§Ã£o hÃ­brido para e-commerce**, combinando sinais comportamentais, semÃ¢nticos e contextuais para gerar recomendaÃ§Ãµes personalizadas e escalÃ¡veis.

O objetivo Ã© simular **um ambiente real de produÃ§Ã£o**, cobrindo todo o ciclo de vida de um projeto de Data Science aplicado: modelagem relacional, EDA em SQL, construÃ§Ã£o de modelos de Machine Learning, avaliaÃ§Ã£o offline rigorosa e deploy em cloud (AWS).

A soluÃ§Ã£o integra:

* **Item-Item Collaborative Filtering**
* **Content-Based Filtering (TF-IDF)**
* **Association Rules (Apriori)**

Treinados **offline** e servidos **via API serverless**, seguindo boas prÃ¡ticas de engenharia e controle de custos.

---

## # Project Structure

O fluxo do projeto segue uma arquitetura end-to-end:

1. Objetivo de negÃ³cio
2. Mapeamento e geraÃ§Ã£o de dados
3. IngestÃ£o (CSV â†’ MySQL)
4. EDA em SQL
5. ExportaÃ§Ã£o para Python
6. Feature Engineering
7. Modelagem (CF, CB, AR)
8. AvaliaÃ§Ã£o offline
9. Modelo hÃ­brido final
10. Deploy (AWS S3 + Lambda + API Gateway)

```mermaid
flowchart TD
A[Objetivo de NegÃ³cio]
--> B[Mapeamento de Dados]
--> C[IngestÃ£o CSV â†’ MySQL]
--> D[EDA SQL]
--> E[Export p/ Python]
--> F[Preprocessing]
--> G[Feature Engineering]
--> H[Modelagem ML]
--> I[AvaliaÃ§Ã£o]
--> J[Deploy AWS]
--> K[Entrega: API + QMD]
```

---

## # Data Sources
          
* Tabelas:

  * `customers`
  * `products`
  * `transactions`
  * `product_views`

Granularidade por item (linha = item comprado), simulando logs reais de e-commerce.

---

## # SQL Database & EDA

Antes da modelagem em Python, os dados sÃ£o explorados diretamente no **MySQL**, garantindo integridade, entendimento do comportamento e suporte Ã s decisÃµes de modelagem.

### ðŸŽ¥ Video â€” Database Schema & SQL Setup

{{< video sql_schema_and_setup.mp4 >}}

---

## ## SQL Sanity Checks

#| echo: true
#| warning: false
#| message: false

from sqlalchemy import create_engine, text
import pandas as pd

engine = create_engine(CONN_STR, echo=False)

sql = """
SELECT
(SELECT COUNT(*) FROM customers) AS n_customers,
(SELECT COUNT(*) FROM products) AS n_products,
(SELECT COUNT(*) FROM transactions) AS n_transactions,
(SELECT COUNT(*) FROM product_views) AS n_views;
"""
pd.read_sql_query(sql=text(sql), con=engine)

DecisÃ£o: base Ã­ntegra, sem nulos ou duplicaÃ§Ãµes â€” apta para modelagem.

---

## ## SQL EDA (Business Insights)

* Top produtos por quantidade e receita
* DistribuiÃ§Ã£o de preÃ§os
* SÃ©rie temporal de vendas
* RFM
* Views â†’ Buys
* Sparsity da matriz cliente Ã— produto

# exemplo de uma query jÃ¡ existente no seu notebook

sql = """
SELECT p.category, SUM(t.total_value) AS revenue
FROM transactions t
JOIN products p ON t.product_id = p.product_id
GROUP BY p.category
ORDER BY revenue DESC;
"""
pd.read_sql_query(sql=text(sql), con=engine)

### ðŸŽ¥ Video â€” SQL EDA & Business Insights

{{< video sql_eda_analysis.mp4 >}}

---

## # Modeling Strategy

A EDA revela:

* Alta **sparsity (~93%)**
* Forte sinal comportamental
* Necessidade de **modelo hÃ­brido**

DecisÃ£o arquitetural:

* CF como sinal principal
* CB para cold start e cobertura
* AR para cross-sell contextual

---

## # Item-Item Collaborative Filtering

#| echo: true
from sklearn.metrics.pairwise import cosine_similarity

(âš ï¸ aqui vocÃª **cola exatamente o cÃ³digo do notebook**, sem alterar)

**Justificativa:**
Item-based CF Ã© mais robusto e escalÃ¡vel em matrizes esparsas tÃ­picas de e-commerce.

---

## # Content-Based Filtering (TF-IDF)

# TF-IDF sobre nome, categoria e marca

Complementa CF, mitigando cold start de produtos e ampliando cobertura.

---

## # CF vs CB â€” Offline Evaluation

Antes do hÃ­brido, os modelos sÃ£o avaliados separadamente usando **Leave-One-Out temporal** e **Hit Rate@K**.

# avaliaÃ§Ã£o CF vs CB

Resultado: CF domina, CB agrega valor incremental.

---

## # Hybrid Model â€” Weight Tuning

# tuning de pesos

Melhor resultado:

* `w_cf = 0.6`
* `w_cb = 0.4`

---

## # Association Rules (Apriori)

Regras de associaÃ§Ã£o capturam padrÃµes explÃ­citos de co-ocorrÃªncia:

> *â€œQuem compra X costuma comprar Yâ€*

# Apriori + rules

Uso **controlado**, apenas quando aplicÃ¡vel.

---

## # Final Hybrid Recommender

CombinaÃ§Ã£o:

* CF (personalizaÃ§Ã£o)
* CB (semÃ¢ntica)
* AR (cross-sell)

# recommend_hybrid()

---

## # Offline Artifacts

Os modelos sÃ£o treinados offline e serializados:

# salvar artefatos

> **Em produÃ§Ã£o, a API apenas carrega artefatos e faz ranking.**

---

## # Cloud Deployment (AWS)

### ðŸŽ¥ Video â€” AWS Deploy + API Demo

{{< video aws_lambda_api_demo.mp4 >}}

* S3 â†’ armazenamento dos artefatos
* Lambda â†’ inferÃªncia
* API Gateway â†’ REST

---

## # Conclusion

Este projeto demonstra a construÃ§Ã£o de um **sistema de recomendaÃ§Ã£o hÃ­brido completo**, indo alÃ©m da modelagem e abordando desafios reais de produÃ§Ã£o: dados, arquitetura, avaliaÃ§Ã£o, deploy e custo.
